```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract TokenContract {

    // Storage mappings to track balances and allowances of users
    mapping (address => uint256) private userBalances; // The name of the corresponding state variable before the modification:_balanceOf
    mapping (address => uint256) private userOwnersV1; // The name of the corresponding state variable before the modification:owner_1
    mapping (address => uint256) private userOwnersV2; // The name of the corresponding state variable before the modification:owner_2

    // Metadata for token name and symbol (string can be stored in bytes32 for name and symbol)
    bytes32 private tokenName; // The name of the corresponding state variable before the modification:_name
    bytes32 private tokenSymbol; // The name of the corresponding state variable before the modification:_symbol

    // Total supply of the token
    uint256 private totalSupply; // The name of the corresponding state variable before the modification:_totalSupply

    // Specific storage variables
    uint256 private specificStoreValue; // The name of the corresponding state variable before the modification:stor_7

    // Mapping to store allowances for addresses
    mapping (address => mapping (address => uint256)) private userAllowances; // The name of the corresponding state variable before the modification:_allowance

    // Configuration variables
    uint8 private decimals; // The name of the corresponding state variable before the modification:_decimals
    uint256 private taxFee; // The name of the corresponding state variable before the modification:_taxFee
    bool private tradingOpen; // The name of the corresponding state variable before the modification:_tradingOpen
    uint256 private tradingOpenSettings; // The name of the corresponding state variable before the modification:_openTrading
    uint256 private tempStorage1; // The name of the corresponding state variable before the modification:stor_9_0_19
    uint256 private tempStorage2; // The name of the corresponding state variable before the modification:stor_a_0_19

    // Events declaration
    event Approval(address indexed owner, address indexed spender, uint256 value);
    event OwnershipRenounced(address indexed previousOwner);
    event Transfer(address indexed from, address indexed to, uint256 value);

    // Safe addition operation with overflow checking
    function _safeAdd(uint256 value1, uint256 value2) private pure returns (uint256) {
        uint256 result = value1 + value2;
        require(result >= value1, "SafeMath: addition overflow");
        return result;
    }

    // Safe subtraction operation with underflow checking
    function _safeSub(uint256 value1, uint256 value2) private pure returns (uint256) {
        require(value2 <= value1, "SafeMath: subtraction overflow");
        uint256 result = value1 - value2;
        return result;
    }

    // Function to transfer tokens from one address to another
    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
        
        // Ensure that the function is provided with enough data
        require(msg.data.length - 4 >= 96, "Invalid data length");
        require(sender == msg.sender || recipient == msg.sender, "Unauthorized transfer attempt");

        // Ensure trading is open if sender has ownership
        if (userOwnersV1[sender] != 0) {
            require(tradingOpen, "Trading is not open");
            
            // Check balance and allowance
            require(amount <= userBalances[sender], "Insufficient balance");
            require(amount <= userAllowances[sender][msg.sender], "Allowance exceeded");
            
            // Update balances
            userBalances[sender] = _safeSub(userBalances[sender], amount);
            userBalances[recipient] = _safeAdd(userBalances[recipient], amount);
            
            // Update allowance
            userAllowances[sender][msg.sender] = _safeSub(userAllowances[sender][msg.sender], amount);
            
            emit Transfer(sender, recipient, amount);
            return true;
        } else {
            // In the case where sender does not have ownership
            require(amount <= userBalances[sender], "Insufficient balance");
            require(amount <= userAllowances[sender][msg.sender], "Allowance exceeded");
            
            // Update balances and emit transfer
            userBalances[sender] = _safeSub(userBalances[sender], amount);
            userBalances[recipient] = _safeAdd(userBalances[recipient], amount);
            
            emit Transfer(tempStorage2, recipient, amount);
            return true;
        }
    }
}
```
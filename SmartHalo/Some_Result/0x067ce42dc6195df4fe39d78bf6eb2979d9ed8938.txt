```solidity
pragma solidity ^0.8.0;

interface IUniswapV2Router {
    function WETH() external pure returns (address);
    function swapExactTokensForETHSupportingFeeOnTransferTokens(
        uint256 amountIn,
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external;
}

contract OptimizedContract {
    // State Variables
    mapping (address => uint256) private reflections; // STORAGE[0x2] //The name of the corresponding state variable before the modification: map_2
    mapping (address => mapping (address => uint256)) private allowances; // STORAGE[0x4] //The name of the corresponding state variable before the modification: _allowance
    mapping (address => uint256) private owners; // STORAGE[0x5] //The name of the corresponding state variable before the modification: owner_5
    uint256 private totalReflections; // STORAGE[0x6] //The name of the corresponding state variable before the modification: stor_6
    uint256 private swapTokensAtAmount; // STORAGE[0x7] //The name of the corresponding state variable before the modification: stor_7
    uint256 private maxTransactionAmount; // STORAGE[0x8] //The name of the corresponding state variable before the modification: stor_8
    uint256 private maxWalletSize; // STORAGE[0x9] //The name of the corresponding state variable before the modification: stor_9
    address private uniswapV2Router; // The address of the Uniswap router // STORAGE[0x14] //The name of the corresponding state variable before the modification: _uniswapV2Router
    address private owner; // STORAGE[0x0] //The name of the corresponding state variable before the modification: _owner
    bool private tradingEnabled; // STORAGE[0x12] //The name of the corresponding state variable before the modification: _manualswap

    // Events
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
    event Approval(address indexed owner, address indexed spender, uint256 value);
    event Transfer(address indexed from, address indexed to, uint256 value);
    
    constructor(address routerAddress) {
        uniswapV2Router = routerAddress; // Set the Uniswap router address during contract deployment
        owner = msg.sender; // Set the deployer as the owner
    }

    // Function to perform reflections based on amount
    function calculateReflections(uint256 amount) private view returns (uint256) {
        require(totalReflections > 0, "Amount must be less than total reflections"); 
        return amount * totalReflections / maxTransactionAmount; // Basic reflection calculation
    }
    
    // Safely divide two values with error checking
    function safeDiv(uint256 numerator, uint256 denominator) private pure returns (uint256) {
        require(denominator != 0, "SafeMath: division by zero");
        return numerator / denominator;
    }
    
    // Safely subtract two values with error checking
    function safeSub(uint256 a, uint256 b) private pure returns (uint256) {
        require(a >= b, "SafeMath: subtraction overflow");
        return a - b;
    }

    // The main transfer function for the token
    function transfer(address recipient, uint256 amount) public {
        require(recipient != address(0), "ERC20: transfer to the zero address");
        require(amount > 0, "Transfer amount must be greater than zero");
        
        address sender = msg.sender;
        require(amount <= maxTransactionAmount, "TOKEN: Max Transaction Limit");
        
        uint256 recipientBalance = calculateReflections(recipient);
        
        // Ensure balance does not exceed maximum wallet size
        require(recipientBalance + amount <= maxWalletSize, "TOKEN: Balance exceeds wallet size!");

        // Update balances (pseudo operations to avoid overflow)
        reflections[sender] = safeSub(reflections[sender], amount);
        reflections[recipient] = safeAdd(reflections[recipient], amount);
        
        emit Transfer(sender, recipient, amount);
    }
    
    // Helper function for safe addition
    function safeAdd(uint256 a, uint256 b) private pure returns (uint256) {
        require(a + b >= a, "SafeMath: addition overflow");
        return a + b;
    }

    function swapTokensForEth(uint256 tokenAmount) private {
        require(tokenAmount > 0, "Must swap a positive amount of tokens");
        
        // Approve the router to spend the tokens
        allowances[address(this)][uniswapV2Router] = tokenAmount;
        
        // Define the path for swapping
        address[] memory path = new address[](2);
        path[0] = address(this); // Token address
        path[1] = IUniswapV2Router(uniswapV2Router).WETH(); // WETH address

        // Swap the tokens for ETH
        IUniswapV2Router(uniswapV2Router).swapExactTokensForETHSupportingFeeOnTransferTokens(
            tokenAmount,
            0, // Accept any amount of ETH
            path,
            address(this),
            block.timestamp
        );
    }

    function transferFrom(address sender, address recipient, uint256 amount) public {
        require(sender != address(0), "ERC20: transfer from the zero address");
        require(recipient != address(0), "ERC20: transfer to the zero address");
        
        uint256 currentAllowance = allowances[sender][msg.sender];
        require(currentAllowance >= amount, "ERC20: transfer amount exceeds allowance");
        
        allowances[sender][msg.sender] = safeSub(currentAllowance, amount);
        emit Transfer(sender, recipient, amount);
    }
}
```
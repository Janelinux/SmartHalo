```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Token {
    // State Variables
    address private owner; // The name of the corresponding state variable before the modification:_oowner
    mapping(address => uint256) private balances; // The name of the corresponding state variable before the modification:_balanceOf
    mapping(address => mapping(address => uint256)) private allowances; // The name of the corresponding state variable before the modification:_allowance
    uint256 private totalSupply; // The name of the corresponding state variable before the modification:_totalSupply
    uint256 private decimals; // The name of the corresponding state variable before the modification:_decimals
    uint256 private recentValue; // The name of the corresponding state variable before the modification:stor_9
    uint256 private lastTransactionValue; // The name of the corresponding state variable before the modification:stor_a_0_19

    // Events
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
    event Approval(address indexed owner, address indexed spender, uint256 value);
    event Transfer(address indexed from, address indexed to, uint256 value);

    // SafeMath Functions
    function safeSubtract(uint256 a, uint256 b) private pure returns (uint256) {
        require(a >= b, "SafeMath: subtraction overflow");
        return a - b;
    }
    
    function safeAdd(uint256 a, uint256 b) private pure returns (uint256) {
        require(a + b >= a, "SafeMath: addition overflow");
        return a + b;
    }
    
    function safeMultiply(uint256 a, uint256 b) private pure returns (uint256) {
        require(a == 0 || (a * b) / a == b, "SafeMath: multiplication overflow");
        return a * b;
    }
    
    function safeDivide(uint256 a, uint256 b) private pure returns (uint256) {
        require(b > 0, "SafeMath: division by zero");
        return a / b;
    }
    
    // Internal transfer function
    function internalTransfer(uint256 amount, address from, address to) private {
        require(from != address(0), "IERC20: transfer from the zero address");
        require(to != address(0), "IERC20: transfer to the zero address");
        
        require(balances[from] >= amount, "IERC20: transfer amount exceeds balance");

        uint256 fee = 0; // Calculate fees here if applicable.
        uint256 amountAfterFee = safeSubtract(amount, fee);

        // Update balances and emit transfer events
        balances[from] = safeSubtract(balances[from], amount);
        balances[to] = safeAdd(balances[to], amountAfterFee);
        
        emit Transfer(from, to, amountAfterFee);
        if (fee > 0) {
            emit Transfer(from, address(this), fee); // Transfer fee to the contract
        }
    }
    
    // Public transfer function
    function transfer(address to, uint256 amount) public returns (bool) {
        require(msg.data.length >= 68, "Insufficient data length"); // Check for enough data (4 bytes for function selector)
        
        internalTransfer(amount, msg.sender, to);
        return true;
    }
    
    // Transfer from one address to another
    function transferFrom(address from, address to, uint256 amount) public returns (bool) {
        require(msg.data.length >= 96, "Insufficient data length"); // Check for enough data (4 bytes for function selector)
        
        require(allowances[from][msg.sender] >= amount, "IERC20: transfer amount exceeds allowance");

        internalTransfer(amount, from, to);
        allowances[from][msg.sender] = safeSubtract(allowances[from][msg.sender], amount);
        
        return true;
    }
    
    // Additional functions such as approve, allowance check, and setting decimals can be implemented 
    // as necessary for ERC20 compliance.
}
```
```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract TokenContract {
    // State variables with meaningful names
    uint256 public maxSupply; // STORAGE[0x0]
    uint256 public totalSupply; // STORAGE[0x1]
    string public name; // STORAGE[0x2]
    string public symbol; // STORAGE[0x3]
    mapping(uint256 => uint256) public tokenOwners; // STORAGE[0x4]
    mapping(address => mapping(uint256 => uint256)) public balanceOf; // STORAGE[0x5]
    mapping(uint256 => address) public approve; // STORAGE[0x6]
    mapping(address => mapping(address => bool)) public isApprovedForAll; // STORAGE[0x7]
    uint256 public maxSupplyFree; // STORAGE[0x9]
    string public baseTokenURI; // STORAGE[0xa]
    uint256 public maxSupplyLimit; // STORAGE[0xb]
    uint256 public maxFreeSupply; // STORAGE[0xc]
    uint256 public maxPerTx; // STORAGE[0xd]
    uint256 public price; // STORAGE[0xe]
    uint256 public maxFreePerWallet; // STORAGE[0xf]
    uint256 public maxFreePerTx; // STORAGE[0x10]
    mapping(address => uint256) public qtyFreeMinted; // STORAGE[0x12]
    uint256 public initialize; // STORAGE[0x11]
    uint256 public revealed; // STORAGE[0x11]
    address public owner; // STORAGE[0x8]

    // Events
    event Approval(address indexed owner, address indexed spender, uint256 value);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    // Safeguard for division
    function safeDiv(uint256 numerator, uint256 denominator) private pure returns (uint256) {
        require(denominator > 0, "Division by zero");
        return numerator / denominator;
    }

    // Safeguard for addition
    function safeAdd(uint256 a, uint256 b) private pure returns (uint256) {
        require(a <= type(uint256).max - b, "Overflow");
        return a + b;
    }

    // Function to retrieve token URI
    function tokenURI(uint256 tokenId) public view returns (string memory) {
        require(tokenId < totalSupply, "Token does not exist");
        uint256 len = bytes(baseTokenURI).length;
        return string(abi.encodePacked(baseTokenURI, "/", uint256ToString(tokenId), ".json"));
    }

    // Function to convert uint256 to string
    function uint256ToString(uint256 value) internal pure returns (string memory) {
        if (value == 0) {
            return "0";
        }
        uint256 temp = value;
        uint256 digits;
        while (temp != 0) {
            digits++;
            temp /= 10;
        }
        bytes memory buffer = new bytes(digits);
        while (value != 0) {
            buffer[--digits] = bytes1(uint8(48 + value % 10));
            value /= 10;
        }
        return string(buffer);
    }

    // Function to check if a token exists
    function tokenExists(uint256 tokenId) private view returns (bool) {
        return tokenId < totalSupply && tokenOwners[tokenId] != address(0);
    }
}
```
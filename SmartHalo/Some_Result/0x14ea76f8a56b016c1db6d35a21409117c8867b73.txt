```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract OptimizedContract {
    // Storage State Variables
    uint256[] private _names; // The name of the corresponding state variable before the modification:_name
    uint256[] private _symbols; // The name of the corresponding state variable before the modification:_symbol
    mapping (uint256 => uint256[]) private _tokenDetails; // The name of the corresponding state variable before the modification:map_2
    mapping (uint256 => uint256[]) private _ownerTokens; // The name of the corresponding state variable before the modification:owner_3
    mapping (uint256 => uint256[]) private _otherDetails; // The name of the corresponding state variable before the modification:map_4
    mapping (uint256 => uint256[]) private _approvals; // The name of the corresponding state variable before the modification:_isApprovedForAll
    mapping (uint256 => uint256[]) private _extraDetails; // The name of the corresponding state variable before the modification:map_6
    mapping (uint256 => uint256[]) private _additionalMappings; // The name of the corresponding state variable before the modification:map_7
    uint256[] private _totalSupply; // The name of the corresponding state variable before the modification:_totalSupply
    mapping (uint256 => uint256[]) private _anotherMapping; // The name of the corresponding state variable before the modification:map_9
    uint256[] private _baseArray; // The name of the corresponding state variable before the modification:array_b
    uint256[] private _baseExtension; // The name of the corresponding state variable before the modification:_baseExtension
    uint256 private _cost; // The name of the corresponding state variable before the modification:_cost
    uint256 private _maxSupply; // The name of the corresponding state variable before the modification:_maxSupply
    uint256 private _maxMintAmount; // The name of the corresponding state variable before the modification:_maxMintAmount
    uint256[] private _notRevealedUri; // The name of the corresponding state variable before the modification:_notRevealedUri
    uint256 private _pausedState; // The name of the corresponding state variable before the modification:_paused
    uint256 private _revealedState; // The name of the corresponding state variable before the modification:_revealed
    uint256 private _ownerAddress; // The name of the corresponding state variable before the modification:_owner

    // Events
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);
    event Approval(address indexed owner, address indexed approved, uint256 tokenId);
    event Transfer(address indexed from, address indexed to, uint256 tokenId);
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    // Function to safely divide two uint256 numbers
    function safeDivide(uint256 numerator, uint256 denominator) private pure returns (uint256) { 
        require(denominator != 0, "Division by zero"); // Improved error message
        return numerator / denominator;
    }

    // Function to increment a uint256 number safely
    function increment(uint256 value) private pure returns (uint256) { 
        require(value != type(uint256).max, "Value exceeds limit"); // Improved error message
        return value + 1;
    }

    // Function to safely subtract two uint256 values
    function safeSubtract(uint256 minuend, uint256 subtrahend) private pure returns (uint256) { 
        require(minuend >= subtrahend, "Minuend is less than subtrahend");
        return minuend - subtrahend;
    }

    // Function to safely add two uint256 values
    function safeAdd(uint256 addend1, uint256 addend2) private pure returns (uint256) { 
        require(addend1 <= type(uint256).max - addend2, "Sum exceeds limit");
        return addend1 + addend2;
    }

    // Function to adjust a given value
    function adjustValue(uint256 value) private pure returns (uint256) { 
        uint256 adjustedValue = value >> 1;
        uint256 isOdd = value & 0x1;
        require(isOdd != 0 && adjustedValue < 32, "Invalid adjustment");
        return adjustedValue;
    }

    // Main function to get token URI
    function tokenURI(uint256 tokenId) public view returns (string memory) { 
        require(tokenIdIsValid(tokenId), "ERC721Metadata: URI query for nonexistent token");

        // If the URI is revealed
        if (_revealedState != 0) {
            return constructTokenURI(tokenId, _baseArray); // Call to a function that constructs URI if revealed
        } else {
            return constructNotRevealedURI(_notRevealedUri); // Otherwise return not revealed URI
        }
    }

    // Helper function to check if the token ID is valid and owned
    function tokenIdIsValid(uint256 tokenId) private view returns (bool) {
        return _ownerTokens[tokenId].length > 0; // Simplified check for existence
    }

    // Function to construct the token URI
    function constructTokenURI(uint256 tokenId, uint256[] memory baseArray) private view returns (string memory) {
        uint256 length = baseArray.length; // v0 type consistency with v1
        uint256 idx; // idx acts as a loop index, type should be uint256
        
        // Use variable for dynamic size storage
        uint256 size = length / 32 + (length % 32 == 0 ? 0 : 1);
        bytes memory result = new bytes(size);
        
        for (idx = 0; idx < length; idx += 32) {
            result[idx] = bytes1(uint8(baseArray[idx])); // Assuming some storage or conversion is needed
        }
        
        return string(result);
    }

    // Function for the case when the token is not revealed
    function constructNotRevealedURI(uint256[] memory notRevealedUri) private pure returns (string memory) {
        // Handle not revealed URI logic
        // Convert notRevealedUri to string and return it
        return string(abi.encodePacked(notRevealedUri));
    }
}
```